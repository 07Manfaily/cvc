import React from "react";
import { ToastContainer, toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import Snackbar from '@material-ui/core/Snackbar';
import Alert from '@material-ui/lab/Alert';

class CardID extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      alertRevue: false,
    };
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.state.alertRevue && !prevState.alertRevue) {
      toast.success("Felicitation la revue a été validée avec succès", {
        position: "top-center",
        autoClose: 5000,
        hideProgressBar: false,
        closeOnClick: true,
        pauseOnHover: true,
        draggable: true,
        progress: undefined,
        theme: "dark",
      });
      this.setState({ alertRevue: false });
    }
  }

  render() {
    return (
      <div>
        <Snackbar open={this.state.alertRevue} autoHideDuration={6000}>
          <Alert severity="success">
            Felicitation la revue a été validée avec succès
          </Alert>
        </Snackbar>
        <ToastContainer
          position="top-center"
          autoClose={5000}
          hideProgressBar={false}
          newestOnTop={false}
          closeOnClick
          rtl={false}
          pauseOnFocusLoss
          draggable
          pauseOnHover
          theme="dark"
        />
      </div>
    );
  }
}

export default CardID;



×
Error: Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.
▶ 4 stack frames were collapsed.
CardID.render
D:/dossier_dgc/moana/src/components/CardID.js:960
  957 |                </Alert>
  958 |              </Snackbar>
  959 |              {this.state.alertRevue ?
> 960 | ( toast.success("Felicitation la revue a été validée avec succès", {
      | ^  961 |      position: "top-center",
  962 |      autoClose: 5000,
  963 |      hideProgressBar: false,

      {this.state.alertRevue ?
   ( toast.success("Felicitation la revue a été validée avec succès", {
        position: "top-center",
        autoClose: 5000,
        hideProgressBar: false,
        closeOnClick: true,
        pauseOnHover: true,
        draggable: true,
        progress: undefined,
        theme: "dark"
    })):
    this.setState({alertRevue:false})
}
                {this.state.alertRevue ? (
        <ToastContainer position="top-center"
          autoClose={5000}
          hideProgressBar={false}
          newestOnTop={false}
          closeOnClick
          rtl={false}
          pauseOnFocusLoss
          draggable
          pauseOnHover
          theme="dark"
        />) : ""}



// Étape 1: Identifier les nœuds avec des dépôts, des retraits, ou les deux
const nodeWithBoth = {};
Object.values(node).forEach((n) => {
    if (n.number_deposit > 0 && n.number_withdrawal > 0) {
        nodeWithBoth[n.code_id] = 'both';
    } else if (n.number_deposit > 0) {
        nodeWithBoth[n.code_id] = 'deposit';
    } else if (n.number_withdrawal > 0) {
        nodeWithBoth[n.code_id] = 'withdrawal';
    }
});

// Étape 2: Construire les arêtes
const edges = graphe.map((i) => {
    const isDouble = nodeWithBoth[i.emitter_code_id] === 'both';
    return {
        from: i.emitter_code_id,
        to: i.receiver_code_id,
        color: isDouble ? 'pink' : {
            inherit: 'from',
        },
        smooth: {
            enabled: true,
            type: "continuous",
            roundness: 0.5
        },
        arrows: isDouble ? "to, from" : "to",
        tag: isDouble ? "double" : "normal"
    };
}).concat(Object.values(node).map((n) => {
    if (nodeWithBoth[n.code_id] === 'deposit') {
        return {
            from: n.code_id,
            to: n.code_id,
            label: n.cash_deposit,
            tag: "deposit",
            width: 2,
            hoverWidth: 5,
            color: "orange",
        };
    } else if (nodeWithBoth[n.code_id] === 'withdrawal') {
        return {
            from: n.code_id,
            to: n.code_id,
            label: n.cash_withdrawal,
            tag: "withdrawal",
            width: 2,
            color: "blue",
        };
    } else if (nodeWithBoth[n.code_id] === 'both') {
        return {
            from: n.code_id,
            to: n.code_id,
            label: `${n.cash_deposit} / ${n.cash_withdrawal}`,
            tag: "double",
            width: 2,
            color: "pink",
            arrows: "to, from"
        };
    } else {
        return null;
    }
}).filter(edge => edge !== null));

console.log(edges);






// Étape 1: Identifier les nœuds avec des dépôts et des retraits
const nodeWithBoth = {};
Object.values(node).forEach((n) => {
    if (n.number_deposit > 0 && n.number_withdrawal > 0) {
        nodeWithBoth[n.code_id] = true;
    }
});

// Étape 2: Construire les arêtes
const edges = graphe.map((i) => {
    const isDouble = nodeWithBoth[i.emitter_code_id];
    return {
        from: i.emitter_code_id,
        to: i.receiver_code_id,
        color: isDouble ? 'pink' : {
            inherit: 'from',
        },
        smooth: {
            enabled: true,
            type: "continuous",
            roundness: 0.5
        },
        arrows: isDouble ? "to, from" : "to",
        tag: isDouble ? "double" : "normal"
    };
}).concat(Object.values(node).filter(n => n.number_deposit > 0).map((n) => {
    return {
        from: n.code_id,
        to: n.code_id,
        label: n.cash_deposit,
        tag: "deposit",
        width: 2,
        hoverWidth: 5,
        color: "orange",
    };
})).concat(Object.values(node).filter(n => n.number_withdrawal > 0).map((n) => {
    return {
        from: n.code_id,
        to: n.code_id,
        label: n.cash_withdrawal,
        tag: "withdrawal",
        width: 2,
        color: "blue",
    };
}));

// Télécharger les deux fichiers (dépôt et retrait)
const downloadBothFiles = async () => {
    try {
        setLoadDownload(true);
        const responseDeposit = await axios.post(
            "/api/graph/download",
            {
                "emitter": emetteur,
                "receiver": receveur,
                "cash_transaction": 1 // pour les dépôts
            },
            {
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': getCookie("csrf_refresh_token")
                },
                responseType: 'blob'
            }
        );

        const responseWithdrawal = await axios.post(
            "/api/graph/download",
            {
                "emitter": emetteur,
                "receiver": receveur,
                "cash_transaction": -1 // pour les retraits
            },
            {
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': getCookie("csrf_refresh_token")
                },
                responseType: 'blob'
            }
        );

        if (responseDeposit.status === 200 && responseWithdrawal.status === 200) {
            setLoadDownload(false);

            // Télécharger les deux fichiers
            var fileDeposit = window.URL.createObjectURL(responseDeposit.data);
            var fileWithdrawal = window.URL.createObjectURL(responseWithdrawal.data);

            window.location.assign(fileDeposit);
            window.location.assign(fileWithdrawal);
        }
    } catch (error) {
        console.log("Erreur lors du traitement:", error);
    }
};
